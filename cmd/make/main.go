package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"path"
	"strings"
)

const usage = `Usage:
        make citop       # Build executable and manual pages (requires pandoc)
        make releases    # Build release archives (requires pandoc)
        make clean       # Remove build directory
`

func gitDescribe() (string, error) {
	cmd := exec.Command("git", "describe", "--tags", "--dirty")
	bs, err := cmd.Output()
	if err != nil {
		return "", err
	}

	version := strings.Split(string(bs), "\n")[0]
	return version, nil
}

func goBuild(version string, dir string, env []string) error {
	version = fmt.Sprintf("-X main.Version=%s", version)
	executable := path.Join(dir, "citop")
	fmt.Fprint(os.Stderr, fmt.Sprintf("Building %s...\n", executable))
	wd, err := os.Getwd()
	if err != nil {
		return err
	}
	cmd := exec.Command("go", "build", "-ldflags", version, "-o", executable, path.Join(wd, "cmd", "citop"))
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	cmd.Env = append(os.Environ(), env...)
	return cmd.Run()
}

const manGoTemplate = `// Do not edit. This file was generated by the build script.
package main

import "strings"

const generated = ` + "`%s`" + `

func manualPage() string {
	return strings.Replace(generated, "\\<version\\>", Version, 1)
}
`

func man(version string, dir string) error {
	bs, err := ioutil.ReadFile("man.md")
	if err != nil {
		return err
	}

	markdown := strings.ReplaceAll(string(bs), "\\<version\\>", version)

	output := path.Join(dir, "citop.man.html")
	fmt.Fprint(os.Stderr, fmt.Sprintf("Building %s...\n", output))
	mdToHTML := exec.Command("pandoc", "-s", "-t", "html5", "--template", "pandoc_template.html", "-o", output)
	mdToHTML.Stdin = bytes.NewBufferString(markdown)
	mdToHTML.Stdout = os.Stdout
	mdToHTML.Stderr = os.Stderr
	if err := mdToHTML.Run(); err != nil {
		return err
	}

	stdout := &bytes.Buffer{}
	// FIXME Move this out of here and parametrize the path
	fmt.Fprint(os.Stderr, "Building cmd/citop/man.go...\n")
	mdToGo := exec.Command("pandoc", "-s", "-t", "man")
	mdToGo.Stdin = bytes.NewBufferString(markdown)
	mdToGo.Stdout = stdout
	mdToGo.Stderr = os.Stderr
	if err := mdToGo.Run(); err != nil {
		return err
	}
	manGo := fmt.Sprintf(manGoTemplate, strings.ReplaceAll(stdout.String(), "`", "\"` + \"`\" + `\""))
	if err := ioutil.WriteFile("cmd/citop/man.go", []byte(manGo), os.ModePerm); err != nil {
		return err
	}

	output = path.Join(dir, "citop.man.1")
	fmt.Fprint(os.Stderr, fmt.Sprintf("Building %s...\n", output))
	mdToRoff := exec.Command("pandoc", "-s", "-t", "man", "-o", output)
	mdToRoff.Stdin = bytes.NewBufferString(markdown)
	mdToRoff.Stdout = os.Stdout
	mdToRoff.Stderr = os.Stderr
	return mdToRoff.Run()
}

const licenseHeader = `Below is the license of citop and of every package it uses


===== github.com/nbedos/citop =====
`

func license(dir string) error {
	output := path.Join(dir, "LICENSE")
	fmt.Fprint(os.Stderr, fmt.Sprintf("Building %s...\n", output))
	b := strings.Builder{}
	b.WriteString(licenseHeader)
	bs, err := ioutil.ReadFile("LICENSE")
	if err != nil {
		return err
	}
	if _, err := b.Write(bs); err != nil {
		return err
	}

	goList := exec.Command("go", "list", "-f", "{{.Dir}}", "-m", "all")
	if bs, err = goList.Output(); err != nil {
		return err
	}

	for _, pkgPath := range strings.Split(string(bs), "\n") {
		if !strings.Contains(pkgPath, "citop") {
			licensePath := path.Join(pkgPath, "LICENSE")
			if bs, err = ioutil.ReadFile(licensePath); err == nil {
				b.WriteString("\n\n")
				s := path.Join("go", "pkg", "mod") + string([]rune{os.PathSeparator})
				if n := strings.Index(pkgPath, s); n >= 0 {
					pkgPath = pkgPath[n+len(s):]
				}
				b.WriteString(fmt.Sprintf("===== %s =====\n", pkgPath))
				b.Write(bs)
			}
		}
	}

	return ioutil.WriteFile(output, []byte(b.String()), os.ModePerm)
}

func build(dir string, env []string) error {
	version, err := gitDescribe()
	if err != nil {
		return err
	}
	if err := os.MkdirAll(dir, os.ModePerm); err != nil {
		return err
	}
	if err := man(version, dir); err != nil {
		return err
	}
	if err := goBuild(version, dir, env); err != nil {
		return err
	}

	return license(dir)
}

func releases(dir string, OSesByArch map[string][]string) error {
	version, err := gitDescribe()
	if err != nil {
		return err
	}

	for arch, OSes := range OSesByArch {
		for _, OS := range OSes {
			execVersion := fmt.Sprintf("citop-%s-%s-%s", version, OS, arch)
			buildDir := path.Join(dir, execVersion)

			env := []string{
				fmt.Sprintf("GOOS=%s", OS),
				fmt.Sprintf("GOARCH=%s", arch),
			}
			if err := build(buildDir, env); err != nil {
				return err
			}
		}
	}

	return nil
}

func main() {
	if len(os.Args) != 2 {
		fmt.Fprint(os.Stderr, usage)
		os.Exit(1)
	}

	var err error
	switch os.Args[1] {
	case "usage":
		fmt.Fprint(os.Stderr, usage)
	case "citop":
		err = build("build", nil)
	case "releases":
		OSesByArch := map[string][]string{
			"amd64": {"linux", "freebsd", "openbsd", "netbsd", "darwin"},
		}
		err = releases("build", OSesByArch)
	case "clean":
		err = os.RemoveAll("build")
	default:
		fmt.Fprint(os.Stderr, fmt.Sprintf("unknow command: %q\n", os.Args[1]))
		fmt.Fprint(os.Stderr, usage)
		os.Exit(1)
	}

	if err != nil {
		fmt.Fprint(os.Stderr, err)
		os.Exit(1)
	}
}
